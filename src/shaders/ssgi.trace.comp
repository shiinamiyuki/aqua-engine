#version 450
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_GOOGLE_include_directive : enable
layout(local_size_x = 16, local_size_y = 16) in;

struct PointLight {
    vec3 position;
    vec3 emission;
};

precision highp samplerCube;
layout(set=0, binding=0, rgba32f) uniform image2D color_buf;
layout(set=0, binding=1) uniform sampler s_sampler;
layout(set=0, binding=2) uniform textureCube shadow_map;
layout(set=0, binding=3)  uniform PointLightData {
    PointLight light;
};
layout(set=0, binding=4) buffer Seeds{
    uint seeds[];
};

#define GBUFFER_BINDGROUP 1
#define SSRT_DATA_BINDGROUP 2 
#define DEPTH_LOD_BINDGROUP 3
#define VP_BINDGROUP 4

#include "raytrace.glsl"
#include "bsdf.glsl"
int pixel_idx;

BSDF get_bsdf(ivec2 pixel){
    BSDF bsdf;
    vec3 normal = get_normal(pixel);
    bsdf.frame = frame_from1(normal);
    bsdf.n = normal;
    bsdf.color = vec3(1);
    return bsdf;
}


vec3 direct_lighting(const BSDF bsdf, ivec2 pixel, const vec3 wo) {
    vec3 x = get_pos(pixel);
    vec3 wi = (light.position - x);
    
    float dist_sqr = dot(wi, wi);
    float dist = sqrt(dist_sqr);
    wi /= dist;

    vec3 normal = get_normal(pixel);
    // vec3 offset_x = offset_along_normal(x, normal, wi, 0.01 * (1.0 + dist/(dist + 1.0)));
    float offset_k = mix(0.0001, 0.02, 0.2 * dist);
    vec3 offset_x = x + wi * offset_k / dot(wi, normal);
    
  
    float shadow_depth = texture(samplerCube(shadow_map, s_sampler), -vec3(-wi.x,wi.yz)).x;
    
    bool in_shadow = length(light.position - offset_x) >= shadow_depth;//(shadow_depth * (1.0 + 0.001));
    vec3 L = vec3(0);
    if(!in_shadow){
        vec3 f = evaluate_bsdf(bsdf, wo, wi);
        L += f * max(0.0, dot(normal, wi)) / dist_sqr;
    }
    return L;
}


vec3 ssgi(ivec2 pixel){
    vec3 L = vec3(0);
    vec3 beta = vec3(1);
    vec3 debug = vec3(0);
    float gi_boost = 0.0;
    vec3 wo = -normalize(get_pos(pixel) - ssrt.eye_pos);
    for(int bounce =0; bounce <= 1; bounce++){
        BSDF bsdf = get_bsdf(pixel);
        float boost = bounce == 0 ? 1.0 : (1.0 + gi_boost);
        if(bounce > 0)
            L += beta * boost * min(vec3(3), direct_lighting(bsdf, pixel, wo));
        else
            L += beta * boost * direct_lighting(bsdf, pixel, wo);
        BSDFSample bsdf_sample = sample_bsdf(bsdf, wo);
        vec3 w = bsdf_sample.wi;
        // return w;
        // return 0.5 * get_normal(pixel) + 0.5;
        Ray ray = Ray(get_pos(pixel), w);
        ray.o = offset_ray(ray.o, bsdf.frame.N);
        SSTraceRecord record;
        record.ray = ray;
        record.pixel = pixel;
        record.tmax = 100.0;
        beta *= bsdf_sample.f / bsdf_sample.pdf * abs(dot(bsdf.n, w));
        HitRecord hit;
        if(any(lessThan(beta, vec3(0.0)))){
            break;
        }
        if(trace(record, hit, debug)){
            pixel = ivec2(hit.pixel);
        }else{
            break;
        }
        wo = -ray.d;
    }
    return L;
}
#include "ssrtao.glsl"
vec3 ssr(ivec2 pixel){
    vec3 normal = get_normal(pixel);
    vec3 x = get_pos(pixel);
    vec3 L = vec3(0);
    vec3 wo = -normalize(get_pos(pixel) - ssrt.eye_pos);
    if(normal.y > 0.0 && x.y < 0.1){
        vec3 wo = normalize(x - ssrt.eye_pos);
        vec3 wi = reflect(wo, normal);
        Ray ray = Ray(x, wi);
        SSTraceRecord record;
        record.ray = ray;
        record.pixel = pixel;
            // record.depth = 
        record.tmax = 100.0;
        vec3 debug;
        HitRecord hit;
        
         if(trace(record, hit, debug)){
            pixel = ivec2(hit.pixel);
            BSDF bsdf = get_bsdf(pixel);
            return direct_lighting(bsdf,pixel,-wi);
        }else{
            return vec3(0);
        }
    }else{
        BSDF bsdf = get_bsdf(pixel);
        L =  direct_lighting(bsdf, pixel, wo);
    }
    return L;
}
void main(){
    init_ssrt();
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    // ivec2 image_size = imageSize(color_buf);
    if(any(greaterThanEqual(pixel, ivec2(ssrt.image_width, ssrt.image_height))))
        return;
    pixel_idx = pixel.x + pixel.y * ssrt.image_width;
    seed = seeds[pixel_idx];

    vec3 L = vec3(0);//ssgi(pixel);
    int spp = 1;
    for(int i=0;i<spp;i++){
        L += ssgi(pixel) / spp;
    }
    seeds[pixel_idx] = seed;

    // float depth0 = get_depth(pixel, 0);
    // // float depth1 = texture(sampler2D(depth_lod[max_level-1], s_sampler), vec2(pixel)/vec2(image_width, image_height)).x;
    // vec3 L = vec3(1) * pow(depth0, 32.0);
    vec3 prevL = imageLoad(color_buf, pixel).xyz;
    float alpha = 0.9;
    L = alpha * L + (1.0 - alpha) * prevL;
    L = min(L, vec3(3));
    L = max(L, vec3(0));
    imageStore(color_buf, pixel, vec4(L, 1.0));
}
