#version 450
#extension GL_EXT_nonuniform_qualifier : require
layout(local_size_x = 16, local_size_y = 16) in;

struct PointLight {
    vec3 position;
    vec3 emission;
};

precision highp samplerCube;
layout(set=0, binding=0, rgba32f) uniform image2D color_buf;
layout(set=0, binding=1) uniform sampler s_sampler;
layout(set=0, binding=2) uniform textureCube shadow_map;
layout(set=0, binding=3)  uniform PointLightData {
    PointLight light;
};
layout(set=0, binding=4) buffer Seeds{
    uint seeds[];
};

// layout(set=1, binding=0) uniform texture2D t_depth;
layout(set=1, binding=0, r32f) readonly uniform image2D t_depth;
layout(set=1, binding=1,rgba32f)  readonly uniform image2D t_normal;
layout(set=1, binding=2,rgba32f)  readonly uniform image2D t_world_pos;

layout(set=2, binding=0)
uniform UniformViewProj {
    mat4 view;
    mat4 proj;
}VP;

layout(set=3, binding=0)
uniform texture2D depth_lod[];


layout( push_constant ) uniform PushConstants {
  int light_idx;
  int image_width;
  int image_height;
  vec3 view_dir;
  vec3 eye_pos;
  int _pad0;
  int lod_width;
  int lod_height;
  int max_level;
};

int pixel_idx;
uint seed;

const float PI = 3.1415926535384;
float rand() {
    seed = (seed * uint(1103515245)) + uint(12345);
    return float(seed) / float(uint(0xFFFFFFFF));
}

float origin()      { return 1.0 / 32.0; }
float float_scale() { return 1.0 / 65536.0; }
float int_scale()   { return 256.0; }

// Normal points outward for rays exiting the surface, else is flipped.
vec3 offset_ray(const vec3 p, const vec3 n)
{
  ivec3 of_i = ivec3(int_scale() * n.x, int_scale() * n.y, int_scale() * n.z);

  vec3 p_i = vec3( 
      intBitsToFloat(floatBitsToInt(p.x)+((p.x < 0.0) ? -of_i.x : of_i.x)),
      intBitsToFloat(floatBitsToInt(p.y)+((p.y < 0.0) ? -of_i.y : of_i.y)),
      intBitsToFloat(floatBitsToInt(p.z)+((p.z < 0.0) ? -of_i.z : of_i.z)));

  return vec3(abs(p.x) < origin() ? p.x+ float_scale()*n.x : p_i.x,
                abs(p.y) < origin() ? p.y+ float_scale()*n.y : p_i.y,
                abs(p.z) < origin() ? p.z+ float_scale()*n.z : p_i.z);
}

struct Ray {
    vec3 o;
    vec3 d;
};
struct ScreenSpaceRay {
    vec3 o;
    vec3 d;
    float tmax;
};
struct SSTraceRecord {
    Ray ray;
    vec2 pixel;
    float tmax;
    // float depth;
};
struct HitRecord {
    float t;
    vec2 pixel;
};

struct Frame {
    vec3 T; //x
    vec3 N; //y
    vec3 B; //z
};
Frame frame_from1(vec3 n){
    Frame self;
    vec3 t;
    if(abs(n.x)>abs(n.y)){
        t = normalize(vec3(-n.z, 0, n.x));
    }else{
        t = normalize(vec3(0, n.z, -n.y));
    }
    self.N = n;
    self.T = t;
    self.B = normalize(cross(self.N, self.T));
    return self;
}

Frame ssframe(vec3 w){

/*

N -> T
|
V
B
*/
    Frame self;
    
    self.N = w;
    self.T = normalize(cross(self.N, vec3(0, 1, 0)));
    self.B = normalize(cross(self.N, self.T));
    return self;
}
vec3 to_local(const Frame self, vec3 w){
    return vec3(dot(w, self.T), dot(w, self.N), dot(w, self.B));
}
vec3 to_world(const Frame self, vec3 w){
    return self.T * w.x + self.N * w.y + self.B * w.z;
}
struct BSDF {
    Frame frame;
    vec3 n;
    vec3 color;
};
BSDF get_bsdf(ivec2 pixel){
    BSDF bsdf;
    vec3 normal = imageLoad(t_normal, pixel).xyz;
    bsdf.frame = frame_from1(normal);
    bsdf.n = normal;
    bsdf.color = vec3(1);
    return bsdf;
}
vec3 evaluate_bsdf(const BSDF bsdf, vec3 wo, vec3 wi){
    wo = to_local(bsdf.frame, wo);
    wi = to_local(bsdf.frame, wi);
    if(wo.y * wi.y > 0.0){
        return bsdf.color / PI;
    }else{
        return vec3(0);
    }
}
struct BSDFSample {
    vec3 f;
    float pdf;
    vec3 wi;
    
};
vec3 sample_hemisphere();
BSDFSample sample_bsdf(const BSDF bsdf, vec3 wo){
    vec3 w = sample_hemisphere();
    float pdf = abs(w.y) / PI;
    vec3 f = bsdf.color / PI;
    wo = to_local(bsdf.frame, wo);
    if(wo.y * w.y < 0.0){
        w.y = -w.y;
    }
    w = to_world(bsdf.frame, w);
    return BSDFSample(f, pdf, w);
}


vec3 direct_lighting(const BSDF bsdf, ivec2 pixel, const vec3 wo) {
    vec3 x = imageLoad(t_world_pos, pixel).xyz;
    vec3 normal = imageLoad(t_normal, pixel).xyz;
    vec3 offset_x = offset_ray(x, normal);
    
    vec3 wi = (light.position - x);
    
    float dist_sqr = dot(wi, wi);
    float dist = sqrt(dist_sqr);
    wi /= dist;

    float shadow_depth = texture(samplerCube(shadow_map, s_sampler), -vec3(-wi.x,wi.yz)).x;
    
    bool in_shadow = length(light.position - offset_x) * 0.95 >= shadow_depth;
    vec3 L = vec3(0);
    vec3 f = evaluate_bsdf(bsdf, wo, wi);
    L += f * max(0.0, dot(normal, wi)) / dist_sqr;
    return L;
}

vec3 project_point(mat4 m, vec3 p){
    vec4 h = m * vec4(p, 1.0);
    return h.xyz / h.w;
}
vec3 ndc_to_pixel(vec3 p){
    p.y = -p.y;
    p.xy = ((p.xy + 1.0) / 2.0  * vec2(image_width, image_height));
    return p;
}
ScreenSpaceRay create_ss_ray(const Ray ray, float tmax){

    vec3 p0 = project_point(VP.view, ray.o);
    vec3 d = normalize(mat3(VP.view) * ray.d);// * tmax;
    // vec3 d = normalize(mat3(VP.view) * ray.d);//assume det(VP.view) = 1
    // {
    //     vec3 p1 = project_point(VP.view, ray.o + ray.d * tmax);
    //     d = p1 - p0;
    //     tmax = length(d);
    //     d = normalize(d);
    // }
    if(d.z > 0.0){
        tmax = min(tmax, abs(p0.z / d.z) * 0.999);   
    }
    vec3 p1 = p0 + tmax * d;
    p0 = ndc_to_pixel(project_point(VP.proj, p0));
    p1 = ndc_to_pixel(project_point(VP.proj, p1));
    ScreenSpaceRay ssray;
    ssray.o = p0;
    d = p1 - p0;
    float len = length(d.xy);
    ssray.d = d / len;
    ssray.tmax = len;

    return ssray;
    
}
// ivec2 ndc_to_int(vec2 p){
//     p.y = -p.y;
//     return ivec2((p + 1.0) / 2.0  * vec2(image_width, image_height));
// }
// vec2 ndc_to_tc(vec2 p){
//     p.y = -p.y;
//     return (p + 1.0) / 2.0;
// }
float get_depth(ivec2 pixel, int level){
    if(level == 0)
        return imageLoad(t_depth, pixel).x;
    vec2 tc = vec2(pixel) / vec2(lod_width, lod_height);
    // tc.y = 1.0 - tc.y;
    return texture(sampler2D(depth_lod[level-1], s_sampler), tc).x;
}
bool test_hit(vec3 p, int level){
    ivec2 pixel = ivec2(p.xy);
    if(any(greaterThanEqual(pixel, ivec2(image_width, image_height))))
        return false;
    if(any(lessThan(pixel, ivec2(0))))
        return false;
    float depth = get_depth(pixel, level);
    if(p.z > depth){
        return true;
    }
    return false;
}
#define SSRT_MIPMAP
#ifdef SSRT_MIPMAP
bool trace(const in SSTraceRecord record, inout HitRecord hit, inout vec3 debug){
    ScreenSpaceRay ray = create_ss_ray(record.ray, record.tmax);
    if(dot(ray.d, ray.d)< 1e-5){
        return false;
    }
    debug = vec3(normalize(vec2(ray.d.xy)), 0.0);
    float march_step_base = 1.01;
    vec3 dir = normalize(ray.d);
    float t = 1.001;
    ivec2 prev_pixel = ivec2(ray.o.xy);
    int level = 0;

    int accum_level0_steps = 0;

    while(t < ray.tmax){
        float march_step = march_step_base * (1 << level);
        float next_t = t + march_step;
        
        vec3 p = ray.o + ray.d * next_t;
        ivec2 pixel = ivec2(p.xy);
        bool oob = false;
        if(any(greaterThanEqual(pixel, ivec2(image_width, image_height))))
            oob = true;
        if(any(lessThan(pixel, ivec2(0))))
            oob = true;
        if(next_t > ray.tmax || oob){
            if(level == 0)
                break;
            level--;
            continue;
        }
        if(test_hit(p, level)) {
            if(level == 0){
                hit.t = next_t;
                hit.pixel = p.xy;
                return true;
            }
            level--;
            continue;
        }else{
            t = next_t;
        }
        if(level == 0){
            accum_level0_steps++;
        }else{
            accum_level0_steps = 0;
        }
        if(level == 0){
            if(accum_level0_steps >= 8) {
                level = min(level+1,max_level);
            }
        }else{
            level = min(level+1,max_level);
        }
    }
    return false;
} 
#else
bool trace(const in SSTraceRecord record, inout HitRecord hit, inout vec3 debug){
    ScreenSpaceRay ray = create_ss_ray(record.ray, record.tmax);
    if(dot(ray.d, ray.d)< 1e-5){
        return false;
    }
    debug = vec3(normalize(vec2(ray.d.xy)), 0.0);
    float pixel_dist = length(ray.d.xy);
    // float march_step_ss = 2.0 / max(image_width, image_height);// / 4.0;// * pixel_dist / 1.0;//1.0 / pixel_dist;
    // float march_step = march_step_ss / length(ray.d.xy) * length(ray.d);
    float march_step = 2.01;
    vec3 dir = normalize(ray.d);
    float t = 1.001;
    ivec2 prev_pixel = ivec2(ray.o.xy);
    while(t < ray.tmax){
        vec3 p = ray.o + ray.d * t;
        ivec2 pixel = ivec2(p.xy);
        // if(all(equal(prev_pixel, pixel))){
        //     t += march_step;
        //     continue;
        // }
        if(any(greaterThanEqual(pixel, ivec2(image_width, image_height))))
            return false;
        if(any(lessThan(pixel, ivec2(0))))
            return false;
        // float depth = texture(sampler2D(t_depth, s_sampler),ndc_to_tc(p.xy)).x;
        float depth = get_depth(pixel, 0);
        if(p.z > depth){
            hit.t = t;
            hit.pixel = p.xy;
            return true;
        }
        t += march_step;
        prev_pixel = pixel;
    }
    return false;
} 
#endif
vec2 sample_disk(){
    float r = rand();
    float theta = rand() * 2.0 * PI;
    r = sqrt(r);
    return r * vec2(sin(theta), cos(theta));
}
// struct Bounds2 {
//     vec2 pmin;
//     vec2 pmax;
// };
// Bounds2 get_bbox(ivec2 p, int level) {

// }
vec3 sample_hemisphere(){
    vec2 uv = sample_disk();
    float r = dot(uv, uv);
    float h = sqrt(1.0 - r);
    return vec3(uv.x, h, uv.y);
}
vec3 ssgi(ivec2 pixel){
    vec3 L = vec3(0);
    vec3 beta = vec3(1);
    vec3 debug = vec3(0);
    float gi_boost = 0.0;
    vec3 wo = -normalize(imageLoad(t_world_pos, pixel).xyz - eye_pos);
    for(int bounce =0; bounce <= 1; bounce++){
        BSDF bsdf = get_bsdf(pixel);
        float boost = bounce == 0 ? 1.0 : (1.0 + gi_boost);
        // if(bounce > 0)
            L += beta * boost * direct_lighting(bsdf, pixel, wo);
        
        BSDFSample bsdf_sample = sample_bsdf(bsdf, wo);
        vec3 w = bsdf_sample.wi;
        // return w;
        // return 0.5 * imageLoad(t_normal, pixel).xyz + 0.5;
        Ray ray = Ray(imageLoad(t_world_pos, pixel).xyz, w);
        SSTraceRecord record;
        record.ray = ray;
        record.pixel = pixel;
        record.tmax = 100.0;
        beta *= bsdf_sample.f / bsdf_sample.pdf * abs(dot(bsdf.n, w));
        HitRecord hit;
        if(any(lessThan(beta, vec3(0.0)))){
            break;
        }
        if(trace(record, hit, debug)){
            pixel = ivec2(hit.pixel);
        }else{
            break;
        }
        wo = -ray.d;
    }
    return L;
}
vec3 ssao(ivec2 pixel){
    vec3 normal = imageLoad(t_normal, pixel).xyz;
    vec3 w = sample_hemisphere();
    // vec3 w = normalize()
    // vec3 w = normalize(vec3(-0.4,0.0,0.4));
    // Frame frame = frame_from1(normal);
    // w = to_world(frame, w);
    // return w.zzz;
    // return w;
    return vec3(1.0 / (w.y / PI) - 2.0 * PI);
    Ray ray = Ray(imageLoad(t_world_pos, pixel).xyz, w);
    SSTraceRecord record;
    record.ray = ray;
    record.pixel = pixel;
        // record.depth = 
    record.tmax = 100.0;
    vec3 debug;
    HitRecord hit;
    if(trace(record, hit, debug)){
        pixel = ivec2(hit.pixel);
        return vec3(0);
    }else{
        return vec3(1);
    }
}
vec3 ssr(ivec2 pixel){
    vec3 normal = imageLoad(t_normal, pixel).xyz;
    vec3 x = imageLoad(t_world_pos, pixel).xyz;
    vec3 L = vec3(0);
    vec3 wo = -normalize(imageLoad(t_world_pos, pixel).xyz - eye_pos);
    if(true){
        vec3 wo = normalize(x - eye_pos);
        vec3 wi = reflect(wo, normal);
        Ray ray = Ray(x, wi);
        SSTraceRecord record;
        record.ray = ray;
        record.pixel = pixel;
            // record.depth = 
        record.tmax = 100.0;
        vec3 debug;
        HitRecord hit;
        
         if(trace(record, hit, debug)){
            pixel = ivec2(hit.pixel);
            BSDF bsdf = get_bsdf(pixel);
            return direct_lighting(bsdf,pixel,-wi);
        }else{
            return vec3(0);
        }
    }else{
        BSDF bsdf = get_bsdf(pixel);
        L =  direct_lighting(bsdf, pixel, wo);
    }
    return L;
}
void main(){
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    // ivec2 image_size = imageSize(color_buf);
    if(any(greaterThanEqual(pixel, ivec2(image_width, image_height))))
        return;
    pixel_idx = pixel.x + pixel.y * image_width;
    seed = seeds[pixel_idx];

    vec3 L = vec3(0);//ssgi(pixel);
    int spp = 1;
    for(int i=0;i<spp;i++){
        L += ssgi(pixel) / spp;
    }
    seeds[pixel_idx] = seed;

    // float depth0 = get_depth(pixel, 3);
    // // float depth1 = texture(sampler2D(depth_lod[max_level-1], s_sampler), vec2(pixel)/vec2(image_width, image_height)).x;
    // vec3 L = vec3(1) * pow(depth0, 32.0);

    imageStore(color_buf, pixel, vec4(max(L, vec3(0)), 1.0));
}
