#version 450
layout(local_size_x = 16, local_size_y = 16) in;

struct PointLight {
    vec3 position;
    vec3 emission;
};

precision highp samplerCube;
layout(set=0, binding=0, r32f) uniform image2D color_buf;
layout(set=0, binding=1) uniform sampler s_sampler;
layout(set=0, binding=2) uniform textureCube shadow_map;
layout(set=0, binding=3)  uniform PointLightData {
    PointLight light;
};
layout(set=0, binding=4) buffer Seeds{
    uint seeds[];
};

layout(set=1, binding=0) uniform texture2D t_depth;
layout(set=1, binding=1,rgba32f)  readonly uniform image2D t_normal;
layout(set=1, binding=2,rgba32f)  readonly uniform image2D t_world_pos;

layout(set=2, binding=0)
uniform UniformViewProj {
    mat4 view;
    mat4 proj;
}VP;


layout( push_constant ) uniform PushConstants {
  int light_idx;
  int image_width;
  int image_height;
  vec3 view_dir;
  vec3 eye_pos;
};

int pixel_idx;
uint seed;

const float PI = 3.1415926535384;
float rand() {
    seed = (seed * 1103515245) + 12345;
    return float(seed) / float(uint(0xFFFFFFFF));
}

float origin()      { return 1.0 / 32.0; }
float float_scale() { return 1.0 / 65536.0; }
float int_scale()   { return 256.0; }

// Normal points outward for rays exiting the surface, else is flipped.
vec3 offset_ray(const vec3 p, const vec3 n)
{
  ivec3 of_i = ivec3(int_scale() * n.x, int_scale() * n.y, int_scale() * n.z);

  vec3 p_i = vec3( 
      intBitsToFloat(floatBitsToInt(p.x)+((p.x < 0.0) ? -of_i.x : of_i.x)),
      intBitsToFloat(floatBitsToInt(p.y)+((p.y < 0.0) ? -of_i.y : of_i.y)),
      intBitsToFloat(floatBitsToInt(p.z)+((p.z < 0.0) ? -of_i.z : of_i.z)));

  return vec3(abs(p.x) < origin() ? p.x+ float_scale()*n.x : p_i.x,
                abs(p.y) < origin() ? p.y+ float_scale()*n.y : p_i.y,
                abs(p.z) < origin() ? p.z+ float_scale()*n.z : p_i.z);
}
vec3 direct_lighting(ivec2 pixel) {
    vec3 x = imageLoad(t_world_pos, pixel).xyz;
    vec3 normal = imageLoad(t_normal, pixel).xyz;
    vec3 offset_x = offset_ray(x, normal);
    
    vec3 wi = (light.position - x);
    float dist_sqr = dot(wi, wi);
    float dist = sqrt(dist_sqr);
    wi /= dist;

    float shadow_depth = texture(samplerCube(shadow_map, s_sampler), -vec3(-wi.x,wi.yz)).x;
    
    bool in_shadow = length(light.position - offset_x) * 0.95 >= shadow_depth;
    vec3 L = vec3(0);
    L += vec3(1) * max(0.0,dot(normal, wi)) / dist_sqr;
    return L;
}
struct Ray {
    vec3 o;
    vec3 d;
};
struct SSTraceRecord {
    Ray ray;
    vec2 pixel;
    float tmax;
    // float depth;
};
struct HitRecord {
    float t;
    vec2 pixel;
};

struct Frame {
    vec3 T; //x
    vec3 N; //y
    vec3 B; //z
};
Frame frame_from1(vec3 n){
    Frame self;
    vec3 t;
    if(abs(n.x)>abs(n.y)){
        t = normalize(vec3(-n.z, 0, n.x));
    }else{
        t = normalize(vec3(0, n.z, -n.y));
    }
    self.N = n;
    self.T = t;
    self.B = normalize(cross(self.N, self.T));
    return self;
}
Frame ssframe(vec3 w){

/*

N -> T
|
V
B
*/
    Frame self;
    
    self.N = w;
    self.T = normalize(cross(self.N, vec3(0, 1, 0)));
    self.B = normalize(cross(self.N, self.T));
    return self;
}
vec3 to_local(const Frame self, vec3 w){
    return vec3(dot(w, self.T), dot(w, self.N), dot(w, self.B));
}
vec3 to_world(const Frame self, vec3 w){
    return self.T * w.x + self.N * w.y + self.B * w.z;
}
bool trace(const in SSTraceRecord record, inout HitRecord hit, inout vec3 debug){
    // x -> eye
    float near = 0.001;
    float far = 1000.0;
    mat4 vp = VP.proj * VP.view;
    float ray_length = record.tmax;
    vec3 p0 = record.ray.o;
    vec3 p1 = p0 + ray_length * record.ray.d;
    vec4 cs_p0 = vp * vec4(p0, 1.0);
    vec4 cs_p1 = vp * vec4(p1, 1.0);
    vec3 clip_p0 = cs_p0.xyz / cs_p0.w;
    vec3 clip_p1 = cs_p1.xyz / cs_p1.w;
    vec2 ss_p0 = clip_p0.xy;
    vec2 ss_p1 = clip_p1.xy;
    float ss_ray_length = length(ss_p0 - ss_p1);
    int num_iters = 100;
    float ray_step = ray_length / num_iters;
    float t = 0.0;
    for(int iter = 0;iter<num_iters;iter++){
        t += ray_step;
        vec3 p = record.ray.o + t * record.ray.d;
        vec4 h = vp *vec4(p, 1.0);
        vec3 cs_p = h.xyz / h.w;
        vec2 ss_p = cs_p.xy;
        ivec2 pixel = ivec2((vec2(ss_p.x, -ss_p.y) + 1.0) / 2.0 * vec2(image_width, image_height));
        if(any(greaterThanEqual(pixel, ivec2(image_width, image_height))))
            return false;
        if(any(lessThan(pixel, ivec2(0))))
            return false;
        vec3 x = imageLoad(t_world_pos, pixel).xyz;
        float depth = length(x - eye_pos);
        if(p.z >= depth) {
            hit.t = t;
            hit.pixel = p.xz;
            // debug = vec3(screen_t - 1.0);
            return true;
        } 
    }

    return false;
    // Frame frame = ssframe(normalize(view_dir));
    // vec3 dir = to_local(frame, record.ray.d);
    // debug = dir;
    // // debug = vec3(dot(n, view_dir));//abs(view_dir - record.ray.d);//vec3(dir.xz, 0.0);
    // //vec2 pixel = vec2(record.pixel);
    // vec3 origin = vec3(record.pixel.x, length(record.ray.o - eye_pos), record.pixel.y);
    // float screen_t = 0.0;
    // for(int iter = 0; iter < 100; iter++){
    //     screen_t += 1.0;
    //     vec3 p = origin + screen_t * dir;
    //     // debug = p;
    //     ivec2 pixel = ivec2(p.xz);
    //     if(any(greaterThanEqual(pixel, ivec2(image_width, image_height))))
    //         return false;
    //     if(any(lessThan(pixel, ivec2(0))))
    //         return false;
    //     vec3 x = imageLoad(t_world_pos, pixel).xyz;
    //     float depth = length(x - eye_pos);
    //     if(p.z >= depth) {
    //         hit.screen_t = screen_t;
    //         hit.pixel = p.xz;
    //         // debug = vec3(screen_t - 1.0);
    //         return true;
    //     } 
    // }
    // return false;
} 
vec2 sample_disk(){
    float r = rand();
    float theta = rand() * 2.0 * PI;
    r = sqrt(r);
    return r * vec2(sin(theta), cos(theta));
}
vec3 sample_hemisphere(){
    vec2 uv = sample_disk();
    float r = length(uv);
    float h = 1.0 - r;
    return vec3(uv.x, h, uv.y);
}
vec3 ssgi(ivec2 pixel){
    vec3 L = vec3(0);
    vec3 beta = vec3(1);
    vec3 debug = vec3(0);
    for(int bounce =0; bounce <= 1; bounce++){
        L += beta * direct_lighting(pixel);
        vec3 normal = imageLoad(t_normal, pixel).xyz;
        vec3 w = sample_hemisphere();
        float pdf = abs(w.y) / PI;
        Frame frame = frame_from1(normal);
        w = to_world(frame, w);
        Ray ray = Ray(imageLoad(t_world_pos, pixel).xyz, w);
        SSTraceRecord record;
        record.ray = ray;
        record.pixel = pixel;
        // record.depth = 
        record.tmax = 100.0;
        vec3 bsdf = vec3(1) / PI;
        
        beta *= bsdf / pdf * abs(dot(normal, w));
        HitRecord hit;
        if(trace(record, hit, debug)){
            pixel = ivec2(hit.pixel);
            // L = vec3(1);
            // break;
        }else{
            break;
        }
    }
    return L;
}
void main(){
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 image_size = imageSize(color_buf);
    if(any(greaterThanEqual(pixel, ivec2(image_width, image_height))))
        return;
    pixel_idx = pixel.x + pixel.y * image_width;
    seed = seeds[pixel_idx];

    vec3 L = ssgi(pixel);
    seeds[pixel_idx] = seed;

    imageStore(color_buf, pixel, vec4(L, 1.0));
}
